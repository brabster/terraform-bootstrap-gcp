name: Docker Image CI

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 4 * * *'
  push:
    branches:
      - main
    paths:
      - Dockerfile
      - requirements.txt
      - .github/**
      - scripts/**

jobs:
  build_and_load:
    runs-on: ubuntu-latest # maintained by GitHub
    permissions:
      contents: read
    steps:
    - uses: actions/checkout@v3 # maintained by GitHub

    - name: Build and export Docker image
      run: |
        docker build -t candidate_image:latest .
        docker save candidate_image:latest -o ${{ runner.temp }}/candidate_image.tar
      
    - name: Upload image as artifact
      uses: actions/upload-artifact@v4  # maintained by GitHub
      with:
        name: candidate_image
        path: ${{ runner.temp }}/candidate_image.tar

  osv_scan:
    # see https://github.com/google/osv-scanner-action/blob/main/.github/workflows/osv-scanner-reusable.yml
    runs-on: ubuntu-latest # maintained by GitHub

    permissions:
      actions: read
      contents: read
      security-events: write
    needs: build_and_load
    steps:

    - uses: actions/checkout@v3 # maintained by GitHub

    - name: Download image artifact
      uses: actions/download-artifact@v4 # maintained by GitHub
      with:
        name: candidate_image
        path: ${{ runner.temp }}

    - name: Scan for vulnerabilities
      run: |
        scripts/install_osv_scanner.sh
        scripts/run_osv_scanner.sh scan image --archive "${{ runner.temp }}/candidate_image.tar"
        scripts/run_osv_scanner.sh scan image --archive "${{ runner.temp }}/candidate_image.tar" --format=sarif --output=osv_scan_results.sarif

    - name: Upload OSV scan results
      id: upload_artifact
      if: ${{ always() }}
      uses: actions/upload-artifact@v4
      with:
        name: osv_scan_results_sarif
        path: osv_scan_results.sarif
        retention-days: 5

    - name: Upload OSV scan results to Code Scanning
      if: ${{ always() }}
      uses: github/codeql-action/upload-sarif@v4  # maintained by GitHub
      with:
        sarif_file: osv_scan_results.sarif

    - name: Check if artifact upload failed
      if: ${{ always() && steps.upload_artifact.outcome == 'failure' }}
      run: |
        echo "::error::Artifact upload failed. This is most likely caused by a error during scanning earlier in the workflow."
        exit 1

  image_test:
    runs-on: ubuntu-latest # maintained by GitHub
    needs: build_and_load
    permissions:
      contents: read
    steps:

      - name: Download image artifact
        uses: actions/download-artifact@v4 # maintained by GitHub
        with:
          name: candidate_image
          path: ${{ runner.temp }}

      - uses: actions/checkout@v3 # maintained by GitHub

      - name: test
        shell: bash
        run: |
          set -euo pipefail

          docker load -i ${{ runner.temp }}/candidate_image.tar
          cat ${{ github.workspace }}/scripts/validate_image.sh | docker run --rm -i \
            candidate_image:latest \
            bash

  test_osv_scanner_wrapper:
    runs-on: ubuntu-latest # maintained by GitHub
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4 # maintained by GitHub

      - name: Install osv-scanner
        run: scripts/install_osv_scanner.sh

      - name: Test wrapper script with a valid image
        run: |
          docker pull ubuntu:latest
          scripts/run_osv_scanner.sh scan image ubuntu:latest

      - name: Test wrapper script with a non-existent image
        run: |
          if scripts/run_osv_scanner.sh scan image non-existent-image:latest; then
            echo "::error::Wrapper script succeeded unexpectedly for a non-existent image."
            exit 1
          else
            echo "Wrapper script failed as expected for a non-existent image."
          fi

  publish:
    runs-on: ubuntu-latest # maintained by GitHub
    permissions:
      packages: write
      # id-token: write is required for generating attestations using GitHub's OIDC token
      # This allows the workflow to prove its identity to the attestation service
      # Reference: https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect
      id-token: write
      # attestations: write is required to publish attestations to the repository
      # This permission allows the workflow to write attestation data associated with the published artifacts
      # Reference: https://github.com/actions/attest-build-provenance#permissions
      attestations: write
    needs:
      - build_and_load
      - osv_scan
      - image_test
      - test_osv_scanner_wrapper
    steps:

    - name: Download image artifact
      uses: actions/download-artifact@v4 # maintained by GitHub
      with:
        name: candidate_image
        path: ${{ runner.temp }}

    - name: Log in to the Container registry
      run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    # Push the image and capture its digest for attestation
    # The digest uniquely identifies the image content and is required for attestation
    - name: Push tagged image
      id: push
      env:
        DOCKER_SHA_TAG: ghcr.io/${{ github.repository }}:${{ github.sha }}
        DOCKER_LATEST_TAG: ghcr.io/${{ github.repository }}:latest
      run: |
        docker load -i ${{ runner.temp }}/candidate_image.tar
        for tag in $DOCKER_SHA_TAG $DOCKER_LATEST_TAG; do
          docker tag candidate_image:latest $tag
          docker push $tag
        done
        # Capture the image digest for attestation
        # The digest is the sha256 hash of the image content
        DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $DOCKER_SHA_TAG | cut -d'@' -f2)
        echo "digest=$DIGEST" >> $GITHUB_OUTPUT

    # Generate build provenance attestations for the published Docker images
    # This creates cryptographically signed attestations that prove:
    # 1. The image was built by this specific GitHub Actions workflow
    # 2. The image digest matches what was produced by the workflow
    # 3. Build metadata including workflow, repository, and commit information
    #
    # The attestation is signed using GitHub's Sigstore infrastructure and stored
    # in the repository's attestations, allowing consumers to verify the provenance
    # of the image before use.
    #
    # Consumers can verify the attestation using:
    # gh attestation verify oci://ghcr.io/brabster/terraform-bootstrap-gcp:latest --owner brabster
    #
    # Reference: https://github.com/actions/attest-build-provenance
    - name: Attest build provenance
      uses: actions/attest-build-provenance@v2 # maintained by GitHub
      with:
        # Attest the image by its name and digest
        # Using the digest ensures the attestation is tied to the exact image content
        # rather than a mutable tag
        subject-name: ghcr.io/${{ github.repository }}
        subject-digest: ${{ steps.push.outputs.digest }}
        push-to-registry: true

