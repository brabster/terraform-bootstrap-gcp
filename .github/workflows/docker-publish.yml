name: Docker Image CI

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 4 * * *'
  push:
    branches:
      - main
    paths:
      - Dockerfile
      - requirements.txt
      - .github/**
      - scripts/**
  pull_request:
    paths:
      - Dockerfile
      - requirements.txt
      - .github/**
      - scripts/**

jobs:
  build_and_load:
    runs-on: ubuntu-latest # maintained by GitHub
    permissions:
      contents: read
    steps:
    - uses: actions/checkout@v3 # maintained by GitHub

    - name: Build and export Docker image
      run: |
        docker build -t candidate_image:latest .
        docker save candidate_image:latest -o ${{ runner.temp }}/candidate_image.tar
      
    - name: Upload image as artifact
      uses: actions/upload-artifact@v4  # maintained by GitHub
      with:
        name: candidate_image
        path: ${{ runner.temp }}/candidate_image.tar

  osv_scan:
    # see https://github.com/google/osv-scanner-action/blob/main/.github/workflows/osv-scanner-reusable.yml
    runs-on: ubuntu-latest # maintained by GitHub

    permissions:
      actions: read
      contents: read
      security-events: write
    needs: build_and_load
    steps:

    - uses: actions/checkout@v3 # maintained by GitHub

    - name: Download image artifact
      uses: actions/download-artifact@v4 # maintained by GitHub
      with:
        name: candidate_image
        path: ${{ runner.temp }}

    - name: Scan for vulnerabilities
      run: |
        scripts/install_osv_scanner.sh
        scripts/run_osv_scanner.sh scan image --archive "${{ runner.temp }}/candidate_image.tar"
        scripts/run_osv_scanner.sh scan image --archive "${{ runner.temp }}/candidate_image.tar" --format=sarif --output=osv_scan_results_raw.sarif
        scripts/deduplicate_sarif.sh osv_scan_results_raw.sarif osv_scan_results.sarif

    - name: Upload OSV scan results
      id: upload_artifact
      if: ${{ always() }}
      uses: actions/upload-artifact@v4
      with:
        name: osv_scan_results_sarif
        path: osv_scan_results.sarif
        retention-days: 5

    - name: Upload OSV scan results to Code Scanning
      if: ${{ always() }}
      uses: github/codeql-action/upload-sarif@v4  # maintained by GitHub
      with:
        sarif_file: osv_scan_results.sarif

    - name: Check if artifact upload failed
      if: ${{ always() && steps.upload_artifact.outcome == 'failure' }}
      run: |
        echo "::error::Artifact upload failed. This is most likely caused by a error during scanning earlier in the workflow."
        exit 1

  image_test:
    runs-on: ubuntu-latest # maintained by GitHub
    needs: build_and_load
    permissions:
      contents: read
    steps:

      - name: Download image artifact
        uses: actions/download-artifact@v4 # maintained by GitHub
        with:
          name: candidate_image
          path: ${{ runner.temp }}

      - uses: actions/checkout@v3 # maintained by GitHub

      - name: test
        shell: bash
        run: |
          set -euo pipefail

          docker load -i ${{ runner.temp }}/candidate_image.tar
          cat ${{ github.workspace }}/scripts/validate_image.sh | docker run --rm -i \
            candidate_image:latest \
            bash

  test_osv_scanner_wrapper:
    runs-on: ubuntu-latest # maintained by GitHub
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4 # maintained by GitHub

      - name: Install osv-scanner
        run: scripts/install_osv_scanner.sh

      - name: Test wrapper script with a valid image
        run: |
          docker pull ubuntu:latest
          scripts/run_osv_scanner.sh scan image ubuntu:latest

      - name: Test wrapper script with a non-existent image
        run: |
          if scripts/run_osv_scanner.sh scan image non-existent-image:latest; then
            echo "::error::Wrapper script succeeded unexpectedly for a non-existent image."
            exit 1
          else
            echo "Wrapper script failed as expected for a non-existent image."
          fi

  publish:
    runs-on: ubuntu-latest # maintained by GitHub
    permissions:
      packages: write
      # id-token: write is required for generating attestations using GitHub's OIDC token
      # This allows the workflow to prove its identity to the attestation service
      # Reference: https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect
      id-token: write
      # attestations: write is required to publish attestations to the repository
      # This permission allows the workflow to write attestation data associated with the published artifacts
      # Reference: https://github.com/actions/attest-build-provenance#permissions
      attestations: write
      # pull-requests: write is required to comment on PRs with the published image tag
      pull-requests: write
    needs:
      - build_and_load
      - osv_scan
      - image_test
      - test_osv_scanner_wrapper
    steps:

    - name: Download image artifact
      uses: actions/download-artifact@v4 # maintained by GitHub
      with:
        name: candidate_image
        path: ${{ runner.temp }}

    - name: Log in to the Container registry
      run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

    # Push the image and capture its digest for attestation
    # The digest uniquely identifies the image content and is required for attestation
    # On main branch: push with 'latest' and SHA tags for production use
    # On pull request: push with 'pr-<number>' tag for testing without affecting production tags
    - name: Push tagged image
      id: push
      env:
        DOCKER_SHA_TAG: ghcr.io/${{ github.repository }}:${{ github.sha }}
        DOCKER_LATEST_TAG: ghcr.io/${{ github.repository }}:latest
        DOCKER_PR_TAG: ghcr.io/${{ github.repository }}:pr-${{ github.event.pull_request.number }}
      run: |
        set -euo pipefail
        docker load -i ${{ runner.temp }}/candidate_image.tar
        
        # Function to extract and validate digest from docker push output
        extract_digest() {
          local push_output="$1"
          local digest
          digest=$(echo "$push_output" | grep -oP 'digest: \K(sha256:[a-f0-9]{64})')
          if [ -z "$digest" ]; then
            echo "::error::Failed to extract digest from docker push output"
            echo "Push output was: $push_output"
            exit 1
          fi
          echo "$digest"
        }
        
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # On PR: push only with PR-specific tag
          docker tag candidate_image:latest $DOCKER_PR_TAG
          PUSH_OUTPUT=$(docker push $DOCKER_PR_TAG)
          DIGEST=$(extract_digest "$PUSH_OUTPUT")
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "tag=$DOCKER_PR_TAG" >> $GITHUB_OUTPUT
        else
          # On main: push with both SHA and latest tags
          docker tag candidate_image:latest $DOCKER_SHA_TAG
          PUSH_OUTPUT=$(docker push $DOCKER_SHA_TAG)
          DIGEST=$(extract_digest "$PUSH_OUTPUT")
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          # Push the latest tag (same image, so same digest)
          docker tag candidate_image:latest $DOCKER_LATEST_TAG
          docker push $DOCKER_LATEST_TAG
          echo "tag=$DOCKER_LATEST_TAG" >> $GITHUB_OUTPUT
        fi

    # Generate build provenance attestations for the published Docker images
    # This creates cryptographically signed attestations that prove:
    # 1. The image was built by this specific GitHub Actions workflow
    # 2. The image digest matches what was produced by the workflow
    # 3. Build metadata including workflow, repository, and commit information
    #
    # The attestation is signed using GitHub's Sigstore infrastructure and stored
    # in the repository's attestations, allowing consumers to verify the provenance
    # of the image before use.
    #
    # Consumers can verify the attestation using:
    # gh attestation verify oci://ghcr.io/brabster/terraform-bootstrap-gcp:latest --owner brabster
    #
    # Reference: https://github.com/actions/attest-build-provenance
    - name: Attest build provenance
      uses: actions/attest-build-provenance@v2 # maintained by GitHub
      with:
        # Attest the image by its name and digest
        # Using the digest ensures the attestation is tied to the exact image content
        # rather than a mutable tag
        subject-name: ghcr.io/${{ github.repository }}
        subject-digest: ${{ steps.push.outputs.digest }}
        push-to-registry: true

    # Comment on PR with the published image tag for easy testing
    - name: Comment on PR with image tag
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7 # maintained by GitHub
      with:
        script: |
          const tag = process.env.IMAGE_TAG;
          const comment = `## üê≥ PR Image Published
          
          The Docker image for this PR has been built, tested, and published.
          
          **Image tag:** \`${tag}\`
          
          You can test this image with:
          \`\`\`bash
          docker pull ${tag}
          docker run -it --rm ${tag}
          \`\`\`
          
          Or use it in your workflows:
          \`\`\`yaml
          container:
            image: ${tag}
          \`\`\`
          
          ‚úÖ All tests passed (build, vulnerability scan, image validation)`;
          
          github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: comment
          });
      env:
        IMAGE_TAG: ${{ steps.push.outputs.tag }}

